<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Thomas Mailund" />

<meta name="date" content="2018-04-26" />

<title>Partial evaluation with foolbox</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Partial evaluation with foolbox</h1>
<h4 class="author"><em>Thomas Mailund</em></h4>
<h4 class="date"><em>2018-04-26</em></h4>



<p>An approach to runtime optimisation is <a href="https://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation</a>. It isnâ€™t that complicated an idea; if you are computing the same thing again and again, you would be better off computing it once and remember the result. This idea is used many places, both implementations and in the design of algorithms, where we call the idea things like <em>dynamic programming</em> or <em>memorisation</em>. When it comes to functions, though, it involves evaluating the parts of a function we are able to with the parameters we can fix, and keeping the rest of the function as code that must be evaluated at a later time.</p>
<div id="example" class="section level2">
<h2>Example</h2>
<p>Consider a simple example where we have a function that scales one vector, <code>y</code>, using the mean and standard deviation of another vector <code>x</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1">rescale &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    (y <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">/</span><span class="st"> </span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">}</a></code></pre></div>
<p>The function takes both vectors as input, but we can <a href="https://en.wikipedia.org/wiki/Currying">curry</a> it to get a function of one argument, <code>x</code>, that returns another that also takes one argument, <code>y</code>, and then computes the same expression.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1">rescale_curry &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="cf">function</span>(y) {</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    (y <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">/</span><span class="st"> </span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">}</a></code></pre></div>
<p>This alone can seem a little pointless, but we see that <code>mean(x)</code> and <code>sd(x)</code> only depend on <code>x</code>, so if we need to use the function on many different <code>y</code> vectors, with the same <code>x</code> value, we could rewrite it so these two quantities are computed as soon as <code>x</code> is known, and such that we can reuse these computations for the different values of <code>y</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1">rescale_curry_pe &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    mean_x &lt;-<span class="st"> </span><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    sd_x &lt;-<span class="st"> </span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="cf">function</span>(y) (y <span class="op">-</span><span class="st"> </span>mean_x) <span class="op">/</span><span class="st"> </span>sd_x</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">}</a></code></pre></div>
<p>Currying alone doesnâ€™t change the performance, but combined with the partial evaluationâ€”computing what we can when we know <code>x</code> and before we know <code>y</code>, can have a substantial effect.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1">time_uncurry &lt;-<span class="st"> </span><span class="cf">function</span>(f) {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    n &lt;-<span class="st"> </span><span class="dv">500</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>,  <span class="dv">0</span>,   <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>, <span class="dv">10</span>, <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="kw">replicate</span>(n, <span class="kw">f</span>(x,y))</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">time_curry &lt;-<span class="st"> </span><span class="cf">function</span>(f) {</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    n &lt;-<span class="st"> </span><span class="dv">500</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>,  <span class="dv">0</span>,   <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1000</span>, <span class="dv">10</span>, <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">    g &lt;-<span class="st"> </span><span class="kw">f</span>(x)</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="kw">replicate</span>(n, <span class="kw">g</span>(y))</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    <span class="kw">time_uncurry</span>(rescale),</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">    <span class="kw">time_curry</span>(rescale_curry),</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    <span class="kw">time_curry</span>(rescale_curry_pe)</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">)</a>
<a class="sourceLine" id="cb4-20" data-line-number="20"><span class="co">#&gt; Unit: milliseconds</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"><span class="co">#&gt;                          expr       min        lq      mean    median</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22"><span class="co">#&gt;         time_uncurry(rescale) 22.193766 23.117494 25.194974 24.857187</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23"><span class="co">#&gt;     time_curry(rescale_curry) 22.258533 23.120718 25.628868 24.598172</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24"><span class="co">#&gt;  time_curry(rescale_curry_pe)  3.686013  3.958897  5.673716  4.365657</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25"><span class="co">#&gt;         uq      max neval</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26"><span class="co">#&gt;  26.060309 43.09655   100</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27"><span class="co">#&gt;  26.315421 54.47460   100</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28"><span class="co">#&gt;   6.318538 35.12429   100</span></a></code></pre></div>
<p>The actual performance difference depends, of course, on how many times we call the partial-evaluated function and how complex it is.</p>
</div>
<div id="automatic-partial-evaluation" class="section level2">
<h2>Automatic partial evaluation</h2>
<p>We can use <code>foolbox</code> to automatically partial-evaluate a function by replacing a variable for a value. In the simplest possible form, we simply substitute a value for a variable:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">library</span>(foolbox)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">subst_var_callback &lt;-<span class="st"> </span><span class="cf">function</span>(var, val) {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="cf">function</span>(expr, ...) {</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        <span class="cf">if</span> (expr <span class="op">==</span><span class="st"> </span>var) rlang<span class="op">::</span><span class="kw">expr</span>(<span class="op">!!</span>val)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">        <span class="cf">else</span> expr</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">pe &lt;-<span class="st"> </span><span class="cf">function</span>(fn, var, val) {</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    var &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">enexpr</span>(var) ; <span class="kw">stopifnot</span>(rlang<span class="op">::</span><span class="kw">is_symbol</span>(var))</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    <span class="kw">force</span>(val)</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    fn <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite_with</span>(</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">        <span class="kw">rewrite_callbacks</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="st">            </span><span class="kw">with_symbol_callback</span>(<span class="kw">subst_var_callback</span>(var, val))</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    ) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">remove_formal_</span>(var)</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">}</a></code></pre></div>
<p>We can see this in action by trying it out on the <code>scale</code> function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1">test_x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">round</span>(<span class="dt">digits =</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">rescale_pe &lt;-<span class="st"> </span>rescale <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">rescale_pe</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">#&gt;     (y - mean(c(0.82, 0.17, 0.39)))/sd(c(0.82, 0.17, 0.39))</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="co">#&gt; }</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">test_y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="kw">rescale</span>(test_x, test_y)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="co">#&gt; [1]  207.4550  376.3745 -762.1280 -334.4448  164.2914</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="kw">rescale_pe</span>(test_y)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13"><span class="co">#&gt; [1]  207.4550  376.3745 -762.1280 -334.4448  164.2914</span></a></code></pre></div>
<p>We have inserted a value for <code>x</code>, but that is all. We have also, as it turns out, managed to make our program slower, because even though we run the partially evaluated function 500 times, the cost in runtime of transforming it outweighs whatever gain we get from the transformation.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="kw">time_uncurry</span>(rescale), </a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="kw">time_curry</span>(<span class="cf">function</span>(x) <span class="kw">pe</span>(rescale, x, x))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co">#&gt; Unit: milliseconds</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="co">#&gt;                                       expr      min       lq     mean</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="co">#&gt;                      time_uncurry(rescale) 22.44032 23.26399 25.01438</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="co">#&gt;  time_curry(function(x) pe(rescale, x, x)) 45.32826 46.20095 48.30860</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="co">#&gt;    median       uq      max neval</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="co">#&gt;  24.37594 25.12400 63.30896   100</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="co">#&gt;  46.85086 47.92804 82.75772   100</span></a></code></pre></div>
<p>This is perhaps not so surprising considering that we do not actually <em>evaluate</em> the <code>mean(x)</code> and <code>sd(x)</code> expressions we wanted to evaluate.</p>
<p>We can fix this by trying to evaluate all calls if all their arguments are evaluated, i.e.Â if all their arguments are atomic.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">eval_attempt &lt;-<span class="st"> </span><span class="cf">function</span>(expr, env) {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="kw">tryCatch</span>(rlang<span class="op">::</span><span class="kw">expr</span>(<span class="op">!!</span><span class="kw">eval</span>(expr, env)),</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">             <span class="dt">error =</span> <span class="cf">function</span>(e) expr)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">call_callback &lt;-<span class="st"> </span><span class="cf">function</span>(expr, env, ...) {</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    call_args_atomic &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">call_args</span>(expr) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="st">        </span><span class="kw">Map</span>(rlang<span class="op">::</span>is_atomic, .) <span class="op">%&gt;%</span><span class="st"> </span>unlist</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="cf">if</span> (<span class="kw">any</span>(<span class="op">!</span>call_args_atomic)) expr</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    <span class="cf">else</span> <span class="kw">eval_attempt</span>(expr, env)</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">}</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">pe &lt;-<span class="st"> </span><span class="cf">function</span>(fn, var, val) {</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    var &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">enexpr</span>(var) ; <span class="kw">stopifnot</span>(rlang<span class="op">::</span><span class="kw">is_symbol</span>(var))</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    <span class="kw">force</span>(val)</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    fn <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite_with</span>(</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        <span class="kw">rewrite_callbacks</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="st">            </span><span class="kw">with_symbol_callback</span>(<span class="kw">subst_var_callback</span>(var,val)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="st">            </span><span class="kw">with_call_callback</span>(call_callback)</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    ) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">remove_formal_</span>(var)</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">}</a></code></pre></div>
<p>With this implementation we will actually evaluate the function calls in <code>scale</code> when we substitute <code>x</code> for a value:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">rescale_pe &lt;-<span class="st"> </span>rescale <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">rescale_pe</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="co">#&gt;     (y - 0.46)/0.330605505096331</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="co">#&gt; }</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">rescale</span>(test_x, test_y)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="co">#&gt; [1]  207.4550  376.3745 -762.1280 -334.4448  164.2914</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">rescale_pe</span>(test_y)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="co">#&gt; [1]  207.4550  376.3745 -762.1280 -334.4448  164.2914</span></a></code></pre></div>
<p>We can also see that this improves the performance, although we only get back to the performance we got before the transformation, so for this example we are not gaining enough for it to be worth the effort. Stil, the idea is the important part, and it does show that you can do this with <code>foolbox</code>â€¦</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1">microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="kw">time_uncurry</span>(rescale), </a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="kw">time_curry</span>(<span class="cf">function</span>(x) <span class="kw">pe</span>(rescale, x, x))</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">#&gt; Unit: milliseconds</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="co">#&gt;                                       expr       min       lq     mean</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">#&gt;                      time_uncurry(rescale) 22.135470 22.73335 24.90991</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co">#&gt;  time_curry(function(x) pe(rescale, x, x))  9.982515 10.47236 12.17176</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="co">#&gt;    median       uq      max neval</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10"><span class="co">#&gt;  23.93136 25.75657 55.57123   100</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="co">#&gt;  11.01616 12.96812 42.11383   100</span></a></code></pre></div>
<p>Since we use <code>env</code> in the evaluation we also capture local variables where the function is defined:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1">make_rescale &lt;-<span class="st"> </span><span class="cf">function</span>(m) {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    <span class="cf">function</span>(x, y) (y <span class="op">-</span><span class="st"> </span><span class="kw">m</span>(x))<span class="op">/</span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">}</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">closure_rescale &lt;-<span class="st"> </span><span class="kw">make_rescale</span>(mean)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">closure_rescale <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="co">#&gt; (y - 0.46)/0.330605505096331</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="co">#&gt; &lt;environment: 0x7fc2e7f508c8&gt;</span></a></code></pre></div>
</div>
<div id="function-parameters-and-local-variables" class="section level2">
<h2>Function parameters and local variables</h2>
<p>What about other local functions?</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1">rescale_ms &lt;-<span class="st"> </span><span class="cf">function</span>(x, y, mean, sd)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    (y <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x))<span class="op">/</span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">rescale_ms <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co">#&gt; function (y, mean, sd) </span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">#&gt; (y - 0.46)/0.330605505096331</span></a></code></pre></div>
<p>We evaluate <code>mean(x)</code> and <code>sd(x)</code> in the environment of <code>rescale_ms</code> but <em>not</em> its execution environment. So we evaluate the expressions using the global functions. This will only give the right behaviour if it is these exact two functions that are passed as the arguments.</p>
<p>In general, we should not evaluate functions that are local variables, at least not in the functionâ€™s environment. We can fix this by checking if a function name is a local variable before we evaluate a call:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">is_bound &lt;-<span class="st"> </span><span class="cf">function</span>(var, expr) {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    (rlang<span class="op">::</span><span class="kw">is_symbol</span>(var) <span class="op">||</span><span class="st"> </span><span class="kw">is.character</span>(var)) <span class="op">&amp;&amp;</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="st">        </span><span class="kw">as.character</span>(var) <span class="op">%in%</span><span class="st"> </span><span class="kw">attr</span>(expr, <span class="st">&quot;bound&quot;</span>)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">call_callback &lt;-<span class="st"> </span><span class="cf">function</span>(expr, env, ...) {</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    call_args_atomic &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">call_args</span>(expr) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="st">        </span><span class="kw">Map</span>(rlang<span class="op">::</span>is_atomic, .) <span class="op">%&gt;%</span><span class="st"> </span>unlist</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    <span class="cf">if</span> (<span class="kw">any</span>(<span class="op">!</span>call_args_atomic) <span class="op">||</span><span class="st"> </span><span class="kw">is_bound</span>(expr[[<span class="dv">1</span>]], expr)) expr</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    <span class="cf">else</span> <span class="kw">eval_attempt</span>(expr, env) </a>
<a class="sourceLine" id="cb13-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">pe &lt;-<span class="st"> </span><span class="cf">function</span>(fn, var, val) {</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    var &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">enexpr</span>(var) ; <span class="kw">stopifnot</span>(rlang<span class="op">::</span><span class="kw">is_symbol</span>(var))</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    <span class="kw">force</span>(val)</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">    fn <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite_with</span>(</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">        <span class="kw">rewrite_callbacks</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17"><span class="st">            </span><span class="kw">with_symbol_callback</span>(<span class="kw">subst_var_callback</span>(var,val)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18"><span class="st">            </span><span class="kw">with_call_callback</span>(call_callback)</a>
<a class="sourceLine" id="cb13-19" data-line-number="19">    ) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">remove_formal_</span>(var)</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">}</a>
<a class="sourceLine" id="cb13-21" data-line-number="21"></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">rescale <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb13-23" data-line-number="23"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb13-24" data-line-number="24"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb13-25" data-line-number="25"><span class="co">#&gt;     (y - 0.46)/0.330605505096331</span></a>
<a class="sourceLine" id="cb13-26" data-line-number="26"><span class="co">#&gt; }</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27">rescale_ms <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb13-28" data-line-number="28"><span class="co">#&gt; function (y, mean, sd) </span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29"><span class="co">#&gt; (y - mean(c(0.82, 0.17, 0.39)))/sd(c(0.82, 0.17, 0.39))</span></a></code></pre></div>
<p>Since functions are also data, we can do partial evaluation with them:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1">rescale_ms <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(mean, mean)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="co">#&gt; function (y, sd) </span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co">#&gt; (y - 0.46)/sd(c(0.82, 0.17, 0.39))</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">rescale_ms <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(mean, mean) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(sd, sd)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="co">#&gt; (y - 0.46)/0.330605505096331</span></a></code></pre></div>
<p>What about local variables?</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">rescale_nested &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    move &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) y <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">move</span>(x, y) <span class="op">/</span><span class="st"> </span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">rescale_nested <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="co">#&gt;     move &lt;- function(x, y) y - 0.46</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="co">#&gt;     move(c(0.82, 0.17, 0.39), y)/0.330605505096331</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="co">#&gt; }</span></a></code></pre></div>
<p>Here we are substituting <code>x</code> inside the body of <code>move</code>. It turns out to be okay because we <em>call</em> <code>move</code> with <code>x</code> later, but that is just dumb luck. In general, we donâ€™t want to substitute variables that are local to <em>another</em> local function. We can use a top-down callback to skip a function body if it has the variable we are substituting as a parameter:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1">skip_overscoped_functions &lt;-<span class="st"> </span><span class="cf">function</span>(var_symbol) {</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    var &lt;-<span class="st"> </span><span class="kw">as.character</span>(var_symbol)</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="cf">function</span>(expr, skip, ...) {</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">        <span class="co"># in `function` expressions, the pair-list is element 2</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">        <span class="cf">if</span> (var <span class="op">%in%</span><span class="st"> </span><span class="kw">names</span>(expr[[<span class="dv">2</span>]])) {</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">            <span class="kw">skip</span>(expr)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">        }</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">}</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">pe &lt;-<span class="st"> </span><span class="cf">function</span>(fn, var, val) {</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    var &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">enexpr</span>(var) ; <span class="kw">stopifnot</span>(rlang<span class="op">::</span><span class="kw">is_symbol</span>(var))</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">    <span class="kw">force</span>(val)</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">    fn <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite_with</span>(</a>
<a class="sourceLine" id="cb16-14" data-line-number="14">        <span class="kw">rewrite_callbacks</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15"><span class="st">            </span><span class="kw">with_symbol_callback</span>(<span class="kw">subst_var_callback</span>(var,val)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16"><span class="st">            </span><span class="kw">with_call_callback</span>(call_callback) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="st">            </span><span class="kw">add_topdown_callback</span>(<span class="st">`</span><span class="dt">function</span><span class="st">`</span>, <span class="kw">skip_overscoped_functions</span>(var))</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    ) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">remove_formal_</span>(var)</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">}</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">rescale_nested <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb16-22" data-line-number="22"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb16-23" data-line-number="23"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb16-24" data-line-number="24"><span class="co">#&gt;     move &lt;- function(x, y) y - mean(x)</span></a>
<a class="sourceLine" id="cb16-25" data-line-number="25"><span class="co">#&gt;     move(c(0.82, 0.17, 0.39), y)/0.330605505096331</span></a>
<a class="sourceLine" id="cb16-26" data-line-number="26"><span class="co">#&gt; }</span></a></code></pre></div>
</div>
<div id="evaluating-local-functions" class="section level2">
<h2>Evaluating local functions</h2>
<p>Ok, so now we avoid substituting variables inside a local function, but in this particular case, we <em>would</em> like to substitute in the <em>call</em> to <code>move</code> so we can get <code>mean(x)</code> evaluated there.</p>
<p>To handle local functions there is a bit of work to be done. First, we need a way to evaluate them, and that means partial evaluation. We want to substitute the parameters we know the values of and let the rest remain. We can do this by iteratively going through the parameters in a call and substitute variables like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">pe_call &lt;-<span class="st"> </span><span class="cf">function</span>(fun, expr) {</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    params &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">call_args</span>(<span class="kw">match.call</span>(fun, expr))</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    substitutable &lt;-<span class="st"> </span><span class="kw">Map</span>(rlang<span class="op">::</span>is_atomic, params) <span class="op">%&gt;%</span><span class="st"> </span>unlist</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    not_substitutable &lt;-<span class="st"> </span>params[<span class="op">!</span>substitutable]</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    params &lt;-<span class="st"> </span>params[substitutable]</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    param_names &lt;-<span class="st"> </span><span class="kw">names</span>(params)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb17-8" data-line-number="8">    <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(params)) {</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">        var &lt;-<span class="st"> </span><span class="kw">as.symbol</span>(param_names[i])</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">        fun &lt;-<span class="st"> </span>fun <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe_</span>(var, params[[i]])</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    </a>
<a class="sourceLine" id="cb17-13" data-line-number="13">    rlang<span class="op">::</span><span class="kw">expr</span>((<span class="op">!!</span>fun)(<span class="op">!!!</span>not_substitutable))</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">}</a></code></pre></div>
<p>Here, I assume that I have a <code>pe_</code> function that works like <code>pe</code> but where <code>var</code> is already quoted. I define it below (and redefine <code>pe</code> in terms of it).</p>
<p>With this function we can handle a call. Now, we need to collect all local function expressions and evaluate them into actual functions. We do this in a callback to assignments (<code>&lt;-</code> and <code>=</code>). Iâ€™m not entirely sure how to deal with variables in local functionâ€™s closure. In theory we should be able to do some substitution inside the function and leave those variables alone, but I plan to evaluate the expressions that define the functions, and I need an environment to do this in. This cannot be the execution environmentâ€”it doesnâ€™t exist before we call the functionâ€”so I can only use the function environment. The local variables do not exist there. So I wonâ€™t allow the local function to refer to local variables from outsides its own scope (parameters and local variables inside the function) or the variable we are substituting. This function extracts all symbols used in an expression:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1">collect_all_symbols &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">    expr <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">analyse_expr</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">analyse_expr_with</span>(</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">        <span class="kw">analysis_callbacks</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">with_symbol_callback</span>(</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">            <span class="cf">function</span>(expr, ...) <span class="kw">list</span>(<span class="dt">symbols =</span> <span class="kw">as.character</span>(expr))</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    )) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unlist</span>(<span class="dt">use.names =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">}</a></code></pre></div>
<p>and I can use it in this function for getting hold of local functions:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1">save_local_functions &lt;-<span class="st"> </span><span class="cf">function</span>(expr, env, params, var, fun_table, ...) {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">    <span class="cf">if</span> (<span class="op">!</span>rlang<span class="op">::</span><span class="kw">is_symbol</span>(expr[[<span class="dv">1</span>]])) </a>
<a class="sourceLine" id="cb19-3" data-line-number="3">        <span class="kw">return</span>(expr)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    <span class="cf">if</span> (<span class="op">!</span>rlang<span class="op">::</span><span class="kw">is_call</span>(expr[[<span class="dv">3</span>]]) <span class="op">||</span><span class="st"> </span><span class="kw">length</span>(expr[[<span class="dv">3</span>]]) <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span> <span class="op">||</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5"><span class="st">        </span>expr[[<span class="dv">3</span>]][[<span class="dv">1</span>]] <span class="op">!=</span><span class="st"> &quot;function&quot;</span>) </a>
<a class="sourceLine" id="cb19-6" data-line-number="6">        <span class="kw">return</span>(expr)</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb19-8" data-line-number="8">    fun_name &lt;-<span class="st"> </span><span class="kw">as.character</span>(expr[[<span class="dv">2</span>]])</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">    fun_formals &lt;-<span class="st"> </span>expr[[<span class="dv">3</span>]][[<span class="dv">2</span>]]</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">    fun_body &lt;-<span class="st"> </span>expr[[<span class="dv">3</span>]][[<span class="dv">3</span>]]</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    fun_parameters &lt;-<span class="st"> </span><span class="kw">names</span>(fun_formals)</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">    fun_used_vars &lt;-<span class="st"> </span><span class="kw">collect_all_symbols</span>(fun_body)</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    local_vars &lt;-<span class="st"> </span><span class="kw">attr</span>(expr, <span class="st">&quot;bound&quot;</span>)</a>
<a class="sourceLine" id="cb19-15" data-line-number="15">    </a>
<a class="sourceLine" id="cb19-16" data-line-number="16">    <span class="co"># figure out if the function uses local variables that are not</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">    <span class="co"># passed through the formal parameters</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18">    closure_scope &lt;-<span class="st"> </span><span class="kw">setdiff</span>(fun_used_vars, fun_parameters)</a>
<a class="sourceLine" id="cb19-19" data-line-number="19">    local_closure_scope &lt;-<span class="st"> </span><span class="kw">intersect</span>(local_vars, closure_scope)</a>
<a class="sourceLine" id="cb19-20" data-line-number="20">    <span class="cf">if</span> (<span class="kw">length</span>(local_closure_scope) <span class="op">&gt;</span><span class="st"> </span><span class="dv">2</span>) </a>
<a class="sourceLine" id="cb19-21" data-line-number="21">        <span class="kw">return</span>(expr) </a>
<a class="sourceLine" id="cb19-22" data-line-number="22">    <span class="cf">if</span> (<span class="kw">length</span>(local_closure_scope) <span class="op">==</span><span class="st"> </span><span class="dv">1</span> <span class="op">&amp;&amp;</span></a>
<a class="sourceLine" id="cb19-23" data-line-number="23"><span class="st">        </span>local_closure_scope <span class="op">!=</span><span class="st"> </span><span class="kw">as.character</span>(var))       </a>
<a class="sourceLine" id="cb19-24" data-line-number="24">        <span class="kw">return</span>(expr)</a>
<a class="sourceLine" id="cb19-25" data-line-number="25">    </a>
<a class="sourceLine" id="cb19-26" data-line-number="26">    <span class="co"># create the function and save it as an attribute</span></a>
<a class="sourceLine" id="cb19-27" data-line-number="27">    <span class="kw">stopifnot</span>(<span class="op">!</span><span class="kw">exists</span>(fun_name, fun_table))</a>
<a class="sourceLine" id="cb19-28" data-line-number="28">    fun_table[[fun_name]] &lt;-<span class="st"> </span><span class="kw">eval</span>(expr[[<span class="dv">3</span>]], env)</a>
<a class="sourceLine" id="cb19-29" data-line-number="29">    </a>
<a class="sourceLine" id="cb19-30" data-line-number="30">    expr</a>
<a class="sourceLine" id="cb19-31" data-line-number="31">}</a></code></pre></div>
<p>I store the local functions in a table, <code>fun_table</code>. I will use an environment here, so the callback has side-effects. It is the easiest way to implement this table.</p>
<p>In the call callback I then do partial evaluation on local variables:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">call_callback &lt;-<span class="st"> </span><span class="cf">function</span>(expr, env, fun_table, ...) {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    call_args_atomic &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">call_args</span>(expr) <span class="op">%&gt;%</span><span class="st"> </span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="st">        </span><span class="kw">Map</span>(rlang<span class="op">::</span>is_atomic, .) <span class="op">%&gt;%</span><span class="st"> </span>unlist</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    </a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    fun_name &lt;-<span class="st"> </span><span class="kw">as.character</span>(expr[[<span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    <span class="cf">if</span> (<span class="kw">all</span>(call_args_atomic) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">is_bound</span>(fun_name, expr))</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        <span class="kw">return</span>(<span class="kw">eval_attempt</span>(expr, env))</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">    <span class="co"># if it exists in the function table, we can try a partial evaluation </span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    <span class="co"># of it</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    <span class="cf">if</span> (<span class="kw">is_bound</span>(fun_name, expr) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">exists</span>(fun_name, fun_table)) {</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">        fun &lt;-<span class="st"> </span>fun_table[[fun_name]]</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">        </a>
<a class="sourceLine" id="cb20-14" data-line-number="14">        <span class="co"># if we have all the arguments, we can just call the function</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15">        <span class="co"># and insert the result</span></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">        <span class="cf">if</span> (<span class="kw">all</span>(call_args_atomic))</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">            <span class="kw">return</span>(<span class="kw">do.call</span>(fun, rlang<span class="op">::</span><span class="kw">call_args</span>(expr)))</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">        </a>
<a class="sourceLine" id="cb20-19" data-line-number="19">        <span class="co"># otherwise, we have to try a partial substitution of the function</span></a>
<a class="sourceLine" id="cb20-20" data-line-number="20">        <span class="kw">return</span>(<span class="kw">pe_call</span>(fun, expr))</a>
<a class="sourceLine" id="cb20-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb20-22" data-line-number="22">        </a>
<a class="sourceLine" id="cb20-23" data-line-number="23">    expr</a>
<a class="sourceLine" id="cb20-24" data-line-number="24">}</a></code></pre></div>
<p>We can now put all this together to get a new <code>pe</code> (and <code>pe_</code>) function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1">pe_ &lt;-<span class="st"> </span><span class="cf">function</span>(fn, var, val) {</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="kw">stopifnot</span>(rlang<span class="op">::</span><span class="kw">is_symbol</span>(var))</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="kw">force</span>(val)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    fn <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">rewrite_with</span>(</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">        <span class="kw">rewrite_callbacks</span>() <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="st">            </span><span class="kw">with_symbol_callback</span>(<span class="kw">subst_var_callback</span>(var,val)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="st">            </span><span class="kw">with_call_callback</span>(call_callback) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="st">            </span><span class="kw">add_topdown_callback</span>(<span class="st">`</span><span class="dt">function</span><span class="st">`</span>, <span class="kw">skip_overscoped_functions</span>(var)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="st">            </span><span class="kw">add_topdown_callback</span>(<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>, save_local_functions) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="st">            </span><span class="kw">add_topdown_callback</span>(<span class="st">`</span><span class="dt">=</span><span class="st">`</span>, save_local_functions),</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">        <span class="dt">var =</span> var, <span class="dt">fun_table =</span> rlang<span class="op">::</span><span class="kw">new_environment</span>()</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">    ) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">remove_formal_</span>(var)</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb21-14" data-line-number="14">pe &lt;-<span class="st"> </span><span class="cf">function</span>(fn, var, val) {</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">    var &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">enexpr</span>(var)</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">    <span class="kw">pe_</span>(fn, var, val)</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">}</a>
<a class="sourceLine" id="cb21-18" data-line-number="18"></a>
<a class="sourceLine" id="cb21-19" data-line-number="19">rescale_nested &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">    move &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) y <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb21-21" data-line-number="21">    <span class="kw">move</span>(x, y) <span class="op">/</span><span class="st"> </span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb21-22" data-line-number="22">}</a>
<a class="sourceLine" id="cb21-23" data-line-number="23">rescale_nested <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb21-24" data-line-number="24"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb21-26" data-line-number="26"><span class="co">#&gt;     move &lt;- function(x, y) y - mean(x)</span></a>
<a class="sourceLine" id="cb21-27" data-line-number="27"><span class="co">#&gt;     (function (y) </span></a>
<a class="sourceLine" id="cb21-28" data-line-number="28"><span class="co">#&gt;     y - 0.46)(y = y)/0.330605505096331</span></a>
<a class="sourceLine" id="cb21-29" data-line-number="29"><span class="co">#&gt; }</span></a></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">rescale_nested_pe &lt;-<span class="st"> </span>rescale_nested <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">rescale_nested_pe</a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="co">#&gt; function (y) </span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="co">#&gt;     move &lt;- function(x, y) y - mean(x)</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="co">#&gt;     (function (y) </span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="co">#&gt;     y - 0.46)(y = y)/0.330605505096331</span></a>
<a class="sourceLine" id="cb22-8" data-line-number="8"><span class="co">#&gt; }</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"></a>
<a class="sourceLine" id="cb22-10" data-line-number="10"><span class="kw">rescale</span>(test_x, test_y)</a>
<a class="sourceLine" id="cb22-11" data-line-number="11"><span class="co">#&gt; [1]  207.4550  376.3745 -762.1280 -334.4448  164.2914</span></a>
<a class="sourceLine" id="cb22-12" data-line-number="12"><span class="kw">rescale_nested</span>(test_x, test_y)</a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="co">#&gt; [1]  207.4550  376.3745 -762.1280 -334.4448  164.2914</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14"><span class="kw">rescale_nested_pe</span>(test_y)</a>
<a class="sourceLine" id="cb22-15" data-line-number="15"><span class="co">#&gt; [1]  207.4550  376.3745 -762.1280 -334.4448  164.2914</span></a></code></pre></div>
<p>As it turns out, this solution puts an expression in the scope where local variables will be present, so I didnâ€™t have to do all that checking of the scope. So I will remove it again.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1">save_local_functions &lt;-<span class="st"> </span><span class="cf">function</span>(expr, env, params, var, fun_table, ...) {</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="cf">if</span> (<span class="op">!</span>rlang<span class="op">::</span><span class="kw">is_symbol</span>(expr[[<span class="dv">1</span>]])) </a>
<a class="sourceLine" id="cb23-3" data-line-number="3">        <span class="kw">return</span>(expr)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    <span class="cf">if</span> (<span class="op">!</span>rlang<span class="op">::</span><span class="kw">is_call</span>(expr[[<span class="dv">3</span>]]) <span class="op">||</span><span class="st"> </span><span class="kw">length</span>(expr[[<span class="dv">3</span>]]) <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span> <span class="op">||</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="st">        </span>expr[[<span class="dv">3</span>]][[<span class="dv">1</span>]] <span class="op">!=</span><span class="st"> &quot;function&quot;</span>) </a>
<a class="sourceLine" id="cb23-6" data-line-number="6">        <span class="kw">return</span>(expr)</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    fun_name &lt;-<span class="st"> </span><span class="kw">as.character</span>(expr[[<span class="dv">2</span>]])</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">    <span class="kw">stopifnot</span>(<span class="op">!</span><span class="kw">exists</span>(fun_name, fun_table))</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    fun_table[[fun_name]] &lt;-<span class="st"> </span><span class="kw">eval</span>(expr[[<span class="dv">3</span>]], env)</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">    </a>
<a class="sourceLine" id="cb23-12" data-line-number="12">    expr</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">}</a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">rescale_nested &lt;-<span class="st"> </span><span class="cf">function</span>(x, y, m) {</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    mean &lt;-<span class="st"> </span>m</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    move &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) y <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="kw">move</span>(x, y) <span class="op">/</span><span class="st"> </span><span class="kw">sd</span>(x)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">rescale_nested <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pe</span>(x, test_x)</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="co">#&gt; function (y, m) </span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="co">#&gt; {</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"><span class="co">#&gt;     mean &lt;- m</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11"><span class="co">#&gt;     move &lt;- function(x, y) y - mean(x)</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12"><span class="co">#&gt;     (function (y) </span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13"><span class="co">#&gt;     y - 0.46)(y = y)/0.330605505096331</span></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="co">#&gt; }</span></a></code></pre></div>
<p>This example, however, illustrates that there is still some work that could be done. We could propagate the local value of <code>mean</code> into <code>move</code>. Trying for that, though, leads us into territory I donâ€™t want to enter. It is undecidable to figure out what a local variable is set to at any particular point in a program unless we put some serious restrictions on it or do some serious static analysis to handle special cases where we <em>are</em> able to determine it. For this document, it takes us too far into static analysis, so I will stop here.</p>
<p>In any case, we are now doing so much work with the partial evaluation that we are only making the program slower, and as it is, we only barely got better than the simple <code>rescale</code> function earlier.</p>
<p>I do not know if there is a use for partial evaluation in R. The language is not built for speed in the first place, and optimisations would be better handled in an adaptive virtual machine. If you <em>can</em> find a use for partial evaluation, though, I think you can implement it using <code>foolbox</code>.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
